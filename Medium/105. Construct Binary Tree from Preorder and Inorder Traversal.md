**Problem:**

Given preorder and inorder traversal of a tree, construct the binary tree.

**Note:**
You may assume that duplicates do not exist in the tree.

For example, given

```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```

Return the following binary tree:

```
    3
   / \
  9  20
    /  \
   15   7
```

**Solution:**

Sorry for not figuring out the solution because I haven't type "tree" for about two years

But I check others' solution, I find some interesting answers.

The process of all the solution is:

```
1.The first element in the preorder is the root of every subtree 

2.When we find the same element in the inorder, we split the array into two arrays.

3.According to the elements in the two new inorder, we split preorder into two arrays.
```

So the most easy way is recursion.

We can store the elements in the inorder array in a map in order to find them later easily.

And in the recursion, we pick up every root of subtree and put them according the order.

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        unordered_map<int,int>mp;
        int preIndex = 0;
        
        for(int i=0; i<inorder.size(); i++)
        {
            mp[inorder[i]] = i;
        }
        return builder(inorder, preIndex, 0, inorder.size()-1, preorder, mp);
    }
    
    TreeNode* builder(vector<int>&inorder,int& preIndex, int inStart, int inEnd, vector<int>&preorder, unordered_map<int, int>&mp)
    {
        if(inStart > inEnd){return nullptr;}
        
        int current = preorder[preIndex++];
        
        TreeNode* node = new TreeNode(current);
        
        if(inStart == inEnd){return node;}
        
        int inIndex = mp[current];
        
        node->left = builder(inorder,  preIndex, inStart, inIndex-1, preorder, mp);
        node->right = builder(inorder, preIndex, inIndex+1, inEnd, preorder, mp);
        
        return node;
    }
};
```

And for all the recursion way to solve a problem, we can change it into the stack way.

The stack way is that pushing the tree into the stack, and according to the order in the array, creating  subtrees

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 class Solution {
public:
	TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		if(preorder.size() == 0) return nullptr;
		unordered_map<int, int> order;
		for(int i = 0;i < inorder.size();i++) order[inorder[i]] = i;
		TreeNode* out = new TreeNode(preorder[0]);
		stack<TreeNode*> stak;
		stak.push(out);
		for(int i = 1;i < preorder.size();i++){
			int n = preorder[i];
			if(stak.empty()){
				out -> right = new TreeNode(n);
				stak.push(new TreeNode(n));
			}else{
				TreeNode* now = stak.top();
				if(order[now -> val] > order[n]){
					TreeNode* left = new TreeNode(n);
					stak.push(left);
					now -> left = left;
				}else{
					while(!stak.empty() && order[stak.top() -> val] < order[n]){
						now = stak.top();
						stak.pop();
					}
					TreeNode* right = new TreeNode(n);
					now -> right = right;
					stak.push(right);
				}
			}
		}
		return out;
	}
};
```

