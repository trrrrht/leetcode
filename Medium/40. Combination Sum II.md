**Problem**:

Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sums to `target`.

Each number in `candidates` may only be used **once** in the combination.

**Note:**

- All numbers (including `target`) will be positive integers.
- The solution set must not contain duplicate combinations.

**Example 1:**

```
Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
```

**Example 2:**

```
Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
```

**Solution**:

The way to solve this problem is like "39. Combination Sum", we can easily use DFS to search the combination.But be careful to the start of each DFS step. And to speed up, we can skip the duplicated number in the array (after sort).

And the non-recursion way is also the same. (But maybe I have to type the code by myself for practice).

```c++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int> nums;
        vector<vector<int>> total;
        sort(candidates.begin(), candidates.end());
        dfs(candidates, target, nums, total, 0, 0);
        return total;
    }
    
    void dfs(vector<int>& candidates, int target, vector<int>& nums, vector<vector<int>>& total, int begin, int sum) {
        if (sum > target) {
            return;
        }
        else if (sum == target) {
            total.emplace_back(nums);
            return;
        }
        else {
            for (int i = begin; i < candidates.size(); i++) {
                if (sum + candidates[i] > target) {
                    break;
                }
                nums.emplace_back(candidates[i]);
                dfs(candidates, target, nums, total, i + 1, sum + candidates[i]);
                nums.pop_back();
                while(i + 1 < candidates.size() && candidates[i] == candidates[i + 1]) {
                    i++;
                }
            }
        }
    }
};
```

