**Problem:**

Write an efficient algorithm that searches for a value in an *m* x *n* matrix. This matrix has the following properties:

- Integers in each row are sorted from left to right.
- The first integer of each row is greater than the last integer of the previous row.

**Example 1:**

```
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
```

**Example 2:**

```
Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
```

**Solution:**

The direct solution is 2 Binary Search way, it's easy to understand and also fast.

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.size() == 0) {
            return false;
        }
        int high = matrix.size() - 1;
        int low = 0;
        int mid;
        while(high >= low) {
            mid = low + (high - low) / 2;
            if (matrix[mid].size() == 0) {
                return false;
            }
            if (target <= matrix[mid][matrix[mid].size() - 1] && target >= matrix[mid][0]) {
                int i = matrix[mid].size() - 1;
                int j = 0;
                int k;
                while (i >= j) {
                    k = j + (i - j) / 2;
                    if (matrix[mid][k] == target) {
                        return true;
                    }
                    else if (matrix[mid][k] < target) {
                        j = k + 1;
                    }
                    else if (matrix[mid][k] > target) {
                        i = k - 1;
                    }
                }
                break;
            }
            else if (target > matrix[mid][matrix[mid].size() - 1]) {
                low = mid + 1;
            }
            else if (target < matrix[mid][0]) {
                high = mid - 1;
            }
        }
        return false;
    }
};
```

Also we can change the 2D matrix to 1D, because the array in memory is 1D, so we can reflect the index to 1D, eg. matrix[mid / c]\[mid % c], c == matrix[0].size()

Another trick solution is that when we first set col = matrix[0].size() - 1 and row = 0, using binary search to find the target.

If matrix[row]\[col] < target, we can increase row because [row]\[col] is the biggest value in this row. If matrix[row]\[col] > target, we can decrease col because once matrix[row]\[col] > target, the target either in this row or not in the matrix.

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.size() == 0 || matrix[0].size() == 0)
            return false;

        int n = matrix.size(), m = matrix[0].size();
    
        int row = 0, col = m - 1;
        while(row < n && col >= 0){
            if(matrix[row][col] == target)
                return true;
            else if(matrix[row][col] < target)
                row++;
            else
                col--;
        }
    
        return false;
    }
};
```

