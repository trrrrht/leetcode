**Problem**:

Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

If the target is not found in the array, return `[-1, -1]`.

**Example 1:**

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

**Example 2:**

```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```

**Solution**:

First solution is using brute force way to scan the array.

Second solution is using iterator to find the first target in the array, and then scan the rest of elements in this array to find rightmost target.

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int>::iterator iter = std::find(nums.begin(), nums.end(), target);
        if (iter == nums.end()) {
            return vector{-1, -1};
        }
        else {
            int flag = distance(nums.begin(), iter);
            for (;iter < nums.end(); iter++) {
                if (*iter != target) {
                    break;
                }
            }
            return vector{flag, (int)(iter - 1 - nums.begin())};
        }
    }
};
```

Third solution is using library function "equal_range", which can directly find the range of our target.

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
    	auto it = std::equal_range(nums.begin(), nums.end(), target);
	    if (it.first != nums.end() and *(it.first) == target) {
		    return vector<int> {it.first - nums.begin(), it.second - nums.begin() - 1};    
	    } else {
		    return vector<int> {-1, -1};
	    }
    }
};
```

Fourth solution is using Binary Search:

Here we can change regular Binary Search a little bit. We use a bool variable called **left** to determine whether we should find the leftmost or the rightmost. If we want to find leftmost, when the **nums[mid] <= target**, we should update **high to mid**, because the leftmost must in the subset of [0, mid], otherwise, we have to update **low to mid + 1**. If we want find the rightmost,  we have to do the **reverse** way to update low and high. If we find what we want, we should return low or high (in this case, they are equal).

Or, we can just find **target and target + 1**, using the regular Binary Search, so that we can find the range of target in this array.

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left;
        //left = binarysearch(nums, target, 1);
        left = findFirst(nums, target);
        if (left == nums.size() || nums[left] != target) {
            return vector{-1, -1};
        }
        else {
            int right;
            //right = binarysearch(nums, target, 0);
            right = findFirst(nums, target + 1, left + 1);
            return vector{left, right - 1};
        }   
    }
    
    int findFirst(vector<int>& nums, int target, int startIdx = 0) {
		int i = startIdx, j = nums.size() - 1, m;
		while (i <= j)
		{
			m = (j - i) / 2 + i;
			if (nums[m] < target)
				i = m + 1;
			else
				j = m - 1;
		}
		return i;
	}
    
    int binarysearch(vector<int>& nums, int target, bool left) {
        int low = 0;
        int high = nums.size();
        
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (target < nums[mid] || (left && nums[mid] == target)) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
};
```

