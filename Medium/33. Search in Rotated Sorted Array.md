**Problem**:

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).

You are given a target value to search. If found in the array return its index, otherwise return `-1`.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Solution**:

The general solution of rotated sorted array is that finding the pivot of rotating firstly, and then using binary search to find the target in one side of the array.

When we finding the pivot, we can also use binary sort, but we should be careful the index of the number.Try to use some examples to determine which index we should return.

Then we can check the target in left side of pivot or in right side of it, or both not.

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if (nums.size() == 0) {
            return -1;
        }
        if (nums.size() == 1) {
            if (target == nums[0]) {
                return 0;
            }
            else {
                return -1;
            }
        }
        int pivot = searchpivot(nums);
        if (target >= nums[pivot] && target <= nums[nums.size() - 1]) {
            return binarysearch(nums, target, pivot, nums.size() - 1);
        }
        else if (target >= nums[0] && target <= nums[pivot - 1]) {
            return binarysearch(nums, target, 0, pivot - 1);
        }
        else {
            return -1;
        }
    }
    
    int binarysearch(vector<int>& nums, int target, int low, int high) {
        int mid;
        while(low <= high) {
            mid = low + (high - low) / 2;
            if (nums[mid] < target) {
                low = mid + 1;
            }
            else if (nums[mid] > target) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -1;
    }
    
    int searchpivot(vector<int>& nums) {
        int len = nums.size();
        int high = len - 1;
        int low = 0;
        int mid;
        while (low < high) {
            mid = low + (high - low) / 2;
            if (nums[mid] < nums[len - 1]) {
                high = mid - 1;
            }
            else {
                low = mid + 1;
            }
        }
        if (nums[low] > nums[len - 1] || low == 0) {
            return low + 1;
        }
        else {
            return low;
        }
    }
};
```

Actually, we can just use one binary search to find the target, but it requires patience to consider the condition of "if".

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0) {
            return -1;
        }
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r) {
            int mid = l + (r - l) / 2;
            if(nums[mid] == target) {
                return mid;
            }
            else if((nums[mid] < nums[l] && (nums[r] < target || nums[mid] > target)) || (nums[mid] > nums[l] && nums[l] <= target && nums[mid] > target)){  
                r = mid - 1;
            }
            else {
                l = mid + 1;
            }
        } 
        return -1;
    }
};
```

