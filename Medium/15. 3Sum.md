**Problem**:

Given an array `nums` of *n* integers, are there elements *a*, *b*, *c* in `nums` such that *a* + *b* + *c* = 0? Find all unique triplets in the array which gives the sum of zero.

**Note:**

The solution set must not contain duplicate triplets.

**Example:**

```
Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

**Solution**:

Because the sum of these three numbers should be 0, we can sort these array to skip some steps.

After sorting the array, we can assume that nums[i] <= 0 (i = 0......j - 1) and nums[i] > 0 (i = j......n).

So when we pick one number in nums which **higher than 0**, we can not find two numbers after it to make the sum of these three numbers to be 0. Then we can **skip these numbers** when we pick the first number.

Now we pick one number which lower than or equal to zero, how can we find other two numbers ?

We can just use the similar way in "1. Two Sum" or the similar way in "11. Container With Most Water".

In the solution, I use "11. Container With Most Water" way.Just putting one pointer at **i + 1** (i is the index of our first number), and putting another at **nums.size() - 1**.

Then depending on the sum of these two numbers and the opposite number of the first one, we can move indexes.If the sum is bigger than the opposite number of the first one, we have to move the pointer which is at **nums.size() - 1** to **nums.size() - 2**, because it's too big. Otherwise, we have to move the pointer which is at **i + 1** to **i + 2**.And the rest can be deduced by analogy.

Remember, we also should skip the same number when we try to find these numbers, otherwise we will get reiterated list.

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> n;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) {
                break;
            }
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int num = 0 - nums[i];
            for (int j = i + 1, k = nums.size() - 1; j < k;) {
                int tmp = nums[j] + nums[k];
                if (tmp > num) {
                    k--;
                }
                else if (tmp < num) {
                    j++;
                }
                else {
                	/*vector<int> lis;
                    lis.push_back(nums[i]);
                    lis.push_back(nums[j]);
                    lis.push_back(nums[k]);
                    n.push_back(lis);*/
                    //If we use the way above, the speed will be slower!!!
                    n.push_back(vector<int> {nums[i], nums[j], nums[k]});
                    int f = nums[j];
                    int s = nums[k];
                    j++;
                    k--;
                    while(j < k && nums[j] == f) {
                        j++;
                    }
                    while(j < k && nums[k] == s) {
                        k--;
                    }
                }
            }
        }
        return n;
    }
};
```