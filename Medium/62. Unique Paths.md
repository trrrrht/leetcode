**Problem:**

A robot is located at the top-left corner of a *m* x *n* grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)
Above is a 7 x 3 grid. How many possible unique paths are there?

**Note:** *m* and *n* will be at most 100.

**Example 1:**

```
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
```

**Example 2:**

```
Input: m = 7, n = 3
Output: 28
```

**Solutionï¼š**

Apparently, the most direct way to solve this problem is recursion, but it may cost much time to get the solution.

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int i = 0;
        dfs(1, 1, m, n, i);
        return i;
    }
    
    void dfs(int right, int down, int m, int n, int& i) {
        if (right == m && down == n) {
            i++;
            return;
        }
        else {
            if (right < m) {
                dfs(right + 1, down, m, n, i);
            }
            if (down < n) {
                dfs(right, down + 1, m, n, i);
            }
        }
        return;
    }
};
```

So, we have to find another way.

I realize that when the robot want to go to matrix[i]\[j], it should go to matrix[i]\[j - 1] or matrix[i - 1]\[j] (when j == 0, matrix[i - 1]\[j], when i == 0, matrix[i]\[j - 1], because it can only move down or right.)

So, we can use loops to imitate the recursion, the number of the way to go to matrix[i]\[j] is that the number of the step way to go to **the position we point above' addition **.

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int path[n][m];
        path[0][0] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i > 0 && j > 0) {
                    path[i][j] = path[i][j - 1] + path[i - 1][j];
                }
                else if (j == 0 || i == 0) {
                    path[i][j] = 1;
                }
            }
        }
        return path[n - 1][m - 1];
    }
};
```

And another way can reduce the space, just using O(m), because we can use addition to update the way we get to a specific point directly.

```c++
class Solution {
public:
    int uniquePaths(int m, int n)
    {
        if ((m == n) && (n == 1)) return 1;
        vector<int> vec(m, 1);
        for (int i = 0; i < n - 1; ++i)
        {
            for (int j = m - 2; j >= 0; --j)
            {
                vec[j] += vec[j + 1];
            }
        }
        return vec[0];
    }
};
```

Finally, I see a fabulous way to solve this problem.

We all know the Pascal's triangle which represents Binomial Coefficient. The number of the way to the end is the binomial coefficient of m and n.

The math logic of this solution is that the robot have to use **m + n - 2** steps to get to the end, in these steps, m - 1 is down, n - 1 is right, so this is actually a combination problem. (From m + n - 2 steps piking n - 1)

```c++
class Solution {
public:
  int uniquePaths(int m, int n) {
    return (getBinomialCoefficient(n-1, m+n-2));
  }
private:
  int getBinomialCoefficient(int m, int n) {
    unsigned long result = 1;
    if ( m>n-m )
        m=n-m;
    for (unsigned i=0;i<(unsigned)m;++i)
    {
        result *= ((unsigned)(n-i));
        result /= ((unsigned)(i+1));
    }
    return (int)result;
  }
};
```

