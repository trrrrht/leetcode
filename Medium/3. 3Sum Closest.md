**Problem**:

Given an array `nums` of *n* integers and an integer `target`, find three integers in `nums` such that the sum is closest to `target`. Return the sum of the three integers. You may assume that each input would have exactly one solution.

**Example:**

```
Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```

**Solution**:

The solution is like the solution of "15. 3Sum".We should use two pointers to reduce the complexity of time.(view the comments of "15. 3Sum")

In this problem, we have to find the closest number to the target.So we have to use a variety called "difference", when we pick one number, and find another two numbers, we have to update "difference", according to the sum of these three numbers.

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int num = 0;
        int difference = 17373362;
        for (int i = 0; i < nums.size() - 2; i++) {
            if (i != 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum < target) {
                    left++;
                    if (abs(sum - target) < difference) {
                        difference = abs(sum - target);
                        num = sum;
                    }
                }
                else if (sum > target) {
                    right--;
                    if (abs(sum - target) < difference) {
                        difference = abs(sum - target);
                        num = sum;
                    }
                }
                else {
                    return sum;
                }
            }
        }
        return num;                          
    }
};
```

