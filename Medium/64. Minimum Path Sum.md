**Problem:**

Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

**Example:**

```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```

**Solution:**

The solution of this problem is much like "62. Unique Paths". If we want to know the min step to grid[i]\[j], we have to count the min step of its left and up position (Because we can only move right and down). So pick the min step between left and up position and plus one, we can get the min step of this position.

```c++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        int path[m][n];
        path[0][0] = grid[0][0];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0 && j > 0) {
                    path[i][j] = min(path[i - 1][j], path[i][j - 1]) + grid[i][j];
                }
                else if (i == 0 && j != 0) {
                    path[i][j] = path[i][j - 1] + grid[i][j];
                }
                else if (j == 0 && i != 0) {
                    path[i][j] = path[i - 1][j] + grid[i][j];
                }
            }
        }
        return path[m - 1][n - 1];
    }
};
```

Also, we can use dijkstra algorithm and other graphic algorithm, but it may need too much time for this problem.

