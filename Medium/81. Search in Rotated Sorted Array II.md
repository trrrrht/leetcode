**Problem:**

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,0,1,2,2,5,6]` might become `[2,5,6,0,0,1,2]`).

You are given a target value to search. If found in the array return `true`, otherwise return `false`.

**Example 1:**

```
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
```

**Example 2:**

```
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
```

**Follow up:**

- This is a follow up problem to [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/), where `nums`may contain duplicates.
- Would this affect the run-time complexity? How and why?

**Solution:**

Apparently, the most easy way is to sort this array, and using binary search to find whether the number is in the array.But I think this way is just better than brute force way.

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        int low = 0;
        int high = nums.size() - 1;
        int mid;
        while (low <= high) {
            mid = low + (high - low) / 2;
            if (target == nums[mid]) {
                return true;
            }
            else if (target > nums[mid]) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
        }
        return false;
    }
};
```

My solution is really stupid because its complexity is O(nlogn), but actually we just scan this array, we can use O(n) to find the solution.

Or it's like the problem "33. Search in Rotated Sorted Array", we can search the pivot firstly, and then search either left side or right side

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        return search(nums, 0, nums.size() - 1, target);
    }
    
    bool search(const vector<int>& nums, int begin, int end, int target) {
        if (begin > end || end < 0 || begin > nums.size() - 1) return false;
        if (nums[begin] < nums[end]) {
            return binarySearch(nums, begin, end, target);
        }
        int mid = (end - begin) / 2 + begin;
        if (nums[mid] == target) return true;
        return search(nums, begin, mid - 1, target) || search(nums, mid + 1, end, target);
    }
    
    bool binarySearch(const vector<int>& nums, int begin, int end, int target) {
        while (begin <= end && begin >= 0 && end <= nums.size() - 1) {
            int m = (end - begin) / 2 + begin;
            if (nums[m] == target) return true;
            else if (nums[m] > target) end = m - 1;
            else begin = m + 1;
        }
        return false;
    }
};
```

