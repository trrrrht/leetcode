**Problem**:

Given an array `nums` of *n* integers and an integer `target`, are there elements *a*, *b*, *c*, and *d* in `nums` such that *a* + *b* + *c* + *d* = `target`? Find all unique quadruplets in the array which gives the sum of `target`.

**Note:**

The solution set must not contain duplicate quadruplets.

**Example:**

```
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```

**Solution**:

As we can see, the solution is like "15. 3Sum", we can just use two loops to find the first number and the second number. Then using the "two pointers" way to find another two.

And we can do some improvement, such as skipping some numbers to speed up.

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> n = {};
        if (nums.size() < 4) {
            return n;
        }
        sort(nums.begin(), nums.end());
        for (int t = 0; t < nums.size() - 3; t++) {
            if (t > 0 && nums[t] == nums[t - 1]) {
                continue;
            }
            if (nums[t] + nums[t + 1] + nums[t + 2] + nums[t + 3] > target) {
                break;
            }
            for (int i = t + 1; i < nums.size() - 2; i++) {
                if (i > t + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                if (nums[t] + nums[i] + nums[i + 1] + nums[i + 2] > target) {
                    break;
                }
                int num = target - nums[i] - nums[t];
                for (int j = i + 1, k = nums.size() - 1; j < k;) {
                    int tmp = nums[j] + nums[k];
                    if (tmp > num) {
                        k--;
                    }
                    else if (tmp < num) {
                        j++;
                    }
                    else {
                        n.push_back(vector<int> {nums[i], nums[j], nums[k], nums[t]});
                        int f = nums[j];
                        int s = nums[k];
                        j++;
                        k--;
                        while(j < k && nums[j] == f) {
                            j++;
                        }
                        while(j < k && nums[k] == s) {
                            k--;
                        }
                    }
                }
            }
        }
        return n;
    }
};
```

