**Problem:**

Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![img](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!

**Example:**

```
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

**Solution:**

The first is a brute force way. We can scan each value in the array, from which finding the **rightmost value and the leftmost value (include itself)** . To itself, these to value are the "wall", so we can just use the **min(rightmost, leftmost)** to minus it, thus we can find the water above it.

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0;
        for (int i = 0; i < height.size(); i++) {
            int maxleft = 0;
            int maxright = 0;
            for (int j = i; j < height.size(); j++) {
                maxright = max(maxright, height[j]);
            }
            for(int j = i; j >= 0; j--) {
                maxleft = max(maxleft, height[j]);
            }
            sum += min(maxleft, maxright) - height[i];
        }
        return sum;
    }
};
```

To improve this solution, we can store the leftmost and rightmost instead of scanning the array again and again, it trades space for time.

For each value in the array, its leftmost value is **max(itself, the left value's max of it)**, also, the rightmost value is **max(itself, the right value's max of it)**. So we can scan the array twice, to store each max value.

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() == 0){
            return 0;
        }
        int ans = 0;
        int size = height.size();
        vector<int> left_max(size), right_max(size);
        left_max[0] = height[0];
        for (int i = 1; i < size; i++) {
            left_max[i] = max(height[i], left_max[i - 1]);
        }
        right_max[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--) {
            right_max[i] = max(height[i], right_max[i + 1]);
        }
        for (int i = 1; i < size - 1; i++) {
            ans += min(left_max[i], right_max[i]) - height[i];
        }
        return ans;
    }
};
```

The third is the least obvious way in the author solutions.

In this way, he uses stack to imitate the real world. When we pour water into a container, we can see:

![img](https://assets.leetcode.com/users/leetcodedy/image_1544473946.png)

```
1.When the stack is not empty, and height[current] > height[stack.top()], we can know that the right bound is height[current].And we can see the order of numbers in stack berfore current is descending, so the left value of height[stack.top()] is the left bound.

2.Pop the top element as top, so now the stack.top() is the left bound of last stack.top().

3.The water it can contain is the (min(height[current], height[stack.top()]) - height[top]), And maybe there is other "top" equal to top, so we have to mutiply the distance between current and stack.top().
```

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int ans = 0, current = 0;
        stack<int> st;
        while (current < height.size()) {
            while (!st.empty() && height[current] > height[st.top()]) {
                int top = st.top();
                st.pop();
                if (st.empty()) {
                    break;
                }
                int distance = current - st.top() - 1;
                int bounded_height = min(height[current], height[st.top()]) - height[top];
                ans += distance * bounded_height;
            }
            st.push(current++);
        }
        return ans;
    }
};
```

The fourth solution is using two pointers. We initialize left pointer to 0 and right pointer to height.size() - 1. If we want to find the bound of the container, we have to find the max of left and max of right to current height.

And when we find the max of left and max of right, what determines the height of the water is the min of the two. So, we can use these two pointers to start.

When left < right, it means that we can add left or minus right, so keep going.

In this case, we have to find whether left is bigger or right is bigger to determine whether they could contain water.

If right is bigger, we have to see now whether left is bigger or not than leftmax, if so, then leftmax can not be left bound, so update leftmax and move on.If not, then the height[left] is between leftmax and rightmax, so we can determine the height of water.

Otherwise is the same.

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int ans = 0;
        int left_max = 0, right_max = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);
                ++left;
            }
            else {
                height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);
                --right;
            }
        }
        return ans;
    }
};
```

