**Problem:**

Given a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

**Solution:**

My solution requires carefulness to discuss the situation of two intervals. So actually it's not a good solution.

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        if (intervals.size() == 0) {
            intervals.push_back(newInterval);
            return intervals;
        }
        int i = 0;
        int flag = 0;
        vector<vector<int>> total;
        for (int i = 0; i < intervals.size(); i++) {
            if (intervals[i][0] >= newInterval[0] && intervals[i][1] <= newInterval[1]) {
                continue;
            }
            else if (intervals[i][0] <= newInterval[0] && intervals[i][1] <= newInterval[1] && intervals[i][1] >= newInterval[0]) {
                newInterval[0] = intervals[i][0];
            }
            else if (intervals[i][0] >= newInterval[0] && intervals[i][0] <= newInterval[1] && intervals[i][1] >= newInterval[1]) {
                newInterval[1] = intervals[i][1];
            }
            else if (intervals[i][0] <= newInterval[0] && intervals[i][1] >= newInterval[1]) {
                return intervals;
            }
            else if (intervals[i][1] < newInterval[0]) {
                total.push_back(intervals[i]);
            }
            else if (intervals[i][0] > newInterval[1]) {
                flag++;
                if (flag == 1) {
                    total.push_back(newInterval);
                }
                total.push_back(intervals[i]);
            }
        }
        if (flag == 0) {
            total.push_back(newInterval);
        }
        return total;
    }
};
```

And another solution is like "56. Merge Intervals". Using min and max to remember the overlapping intervals.

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        int lo = newInterval[0], hi = newInterval[1];
        vector<vector<int>> merged;
        bool add = true, insert = false;
        for(const auto &v: intervals) {
            if(v[1] < lo) merged.emplace_back(v);
            else if(v[0] > hi) {
                if(add) {
                    merged.push_back({lo, hi});
                    add = false; // We pushed in the merged interval
                }
                merged.emplace_back(v);
            }
            else {
                lo = min(lo, v[0]);
                hi = max(hi, v[1]);
            }
        }
        if(add) merged.push_back({lo, hi}); // Merged interval not pushed, pushing it in now
        return merged;
    }
};
```

Third solution is using library of C++. The "equal_range" function return bounds so that we can directly find the position newinterval could inserted.

```c++
class Solution {
public:
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
		auto bounds = equal_range(intervals.begin(), intervals.end(), newInterval, [](const vector<int>&a, const vector<int>& b) {return a[1] < b[0];});
		auto it1 = bounds.first;
		auto it2 = bounds.second;
		if (it1 == it2) {
			intervals.insert(it1, newInterval);
		} else {
			-- it2;
			(*it2)[0] = min((*it1)[0], newInterval[0]);
			(*it2)[1] = max((*it2)[1], newInterval[1]);
			intervals.erase(it1, it2);
		} 
		return intervals;
	}
};
```

And if we realize the "equal_range" function by ourselves, we can use binary search to improve speed. Although it's not the fastest solution for this question, it needs us to know.

```c++
class Solution {
public:
    int binary_search(vector<vector<int>>& intervals, int target, int pos) {
        int l = 0, h = intervals.size();
        while (l < h) {
            int mid = (l + h) / 2;
            if (intervals[mid][pos] == target) return mid;
            if (intervals[mid][pos] > target) h = mid;
            else l = mid+1;
        }
        if (pos == 1)
            return l;                  // index of the interval's end point bigger than newInterval.start
        return l-1;                  // index of the interval's start point less than newInterval.end
    }
    
    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {
        vector<vector<int>> res;
        int start_idx = binary_search(intervals, newInterval[0], 1);
        int end_idx = binary_search(intervals, newInterval[1], 0);
        
        if (start_idx <= end_idx) {
            newInterval[0] = min(newInterval[0], intervals[start_idx][0]);
            newInterval[1] = max(newInterval[1], intervals[end_idx][1]);
        }
        
        int i = 0;
        while (i < start_idx) res.emplace_back(intervals[i++]);
        res.emplace_back(newInterval);
        i = end_idx + 1;
        while (i < intervals.size()) res.emplace_back(intervals[i++]);
        return res;
    }
};
```

