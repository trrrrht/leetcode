**Problem:**

Given *n* non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

 

![img](https://assets.leetcode.com/uploads/2018/10/12/histogram.png)
Above is a histogram where width of each bar is 1, given height = `[2,1,5,6,2,3]`.

 

![img](https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png)
The largest rectangle is shown in the shaded area, which has area = `10` unit.

 

**Example:**

```
Input: [2,1,5,6,2,3]
Output: 10
```

**Solution:**

I think this problem is like "11. Container With Most Water", But I can't figure it out. So I just use the brute force way, which means O(n^2) way, to solve this problem, and then checking others' solution.And if I wanna improve this solution, there is a easy way.

For each element, we can say that if we continue moving to next and next, we may meet a bar lower than the first one, at which time we should stop and calculate the non-descend array's area.Because the non-descend array guarantees the height of the rectangle, and also the width of "this height" rectangle.

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int max = 0;
        for (int i = 0; i < heights.size(); i++) {
            int min = heights[i];
            for (int j = i; j < heights.size(); j++) {
                if (min > heights[j]) {
                    min = heights[j];
                }
                int tmp = min * (j - i + 1);
                if (max < tmp) {
                    max = tmp;
                }
            }
        }
        return max;
    }
};
```

I learned the "divide and conquer" way to solve some problems from my algorithm class, but apparently I can not use it flexibly, so I have to read the "Introduction to algorithm" to learn more.

We know that if we find a "pivot" element, we can divide the problem into smaller problems, so we firstly find the min element in this array, and the left and right part of it are two smaller problems.

Then the max rectangle is max left part or max right part or the **smallest element multiply the length of the divided array**.

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {      
        return get_largest_rec(heights, 0, heights.size() - 1);
    }
private:
    int get_largest_rec(vector<int>& heights, int start, int end){
        if(start < 0 || end > heights.size() - 1 || end < start){
            return 0;
        }
        if(start == end){
            return heights[start];
        }
        
        int h_min = heights[start];
        int i_min = start;
        for(int i = start + 1; i <= end; ++i){
            if(h_min > heights[i]){
                h_min = heights[i];
                i_min = i;
            }
        }
        
        int l_max = get_largest_rec(heights, start, i_min - 1);
        int r_max = get_largest_rec(heights, i_min + 1, end);
        int m_max = h_min * (end - start + 1);
        int ans = max(max(l_max, r_max), m_max);
        return ans;
    }
};
```

Finally, we can change this problem to a similar problem, which is called finding the max area for all heights.

It's like the improvement in solution 1, for **each height** in this array, we can find a **rectangle limited by this height**.

Take the picture of the problem as a example:

![img](https://assets.leetcode.com/uploads/2018/10/12/histogram.png)

Assuming that the first index is 1, which height is 2. The rectangle limited by this height is the index of [1, 1]. And for the index 2, height 2 bar, the rectangle is [1, 6]......and so on.

So we can find every rectangle limited by a specific height, and compare them to find the max one(Because we see all elements' max rectangle, the max of them must be the max of this array).

To finish this, we can follow these steps:

```
1.Create a stack.(to make the process easier, we can add 0 to the original array)

2.When the height is a non-descending order, we push elements into the stack.Of if the stack is empty, we also push elements into the stack.

3.When we meet the first "descending" height, we pop the top of the stack and calculate as this equation: height[the poped height] * (the index of "descending height" - the index of "new stack top" - 1)

4.update the max
```

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int max = 0;
        stack<int> s;
        heights.push_back(0);
        for (int i = 0; i < heights.size(); i++) {
            if (s.empty() || heights[i] >= heights[s.top()]) {
                s.push(i);
                continue;
            }
            while (heights[i] < heights[s.top()]) {
                int top = s.top();
                s.pop();
                if (s.empty()) {
                    if (max < heights[top] * i) {
                        max = heights[top] * i;
                    }
                    break;
                }
                else {
                    if (max < heights[top] * (i - s.top() - 1)) {
                        max = heights[top] * (i - s.top() - 1);
                    }
                }
            }
            s.push(i);
        }
        return max;
    }
};
```

