**Problem**:

There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume **nums1** and **nums2** cannot be both empty.

**Example 1:**

```
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
```

**Example 2:**

```
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```

**Solution**:

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> total;
        for(int i = 0; i < nums1.size(); i++) {
            total.push_back(nums1[i]);
        }
        for(int j = 0; j < nums2.size(); j++) {
            total.push_back(nums2[j]);
        }
        sort(total.begin(), total.end());
        if(total.size() % 2 == 0) {
            return (total[total.size() / 2] + total[total.size() / 2 - 1]) / 2.0;
        }
        else {
            return total[total.size() / 2];
        }
    }
};
```

Although the problem needs a **O(log (m+n))** , this **O((m + n)log (m+n))** way can also AC, a brute force way.

Also, we do not need merge two arrays together completely, just half of them, according to the order of the numbers.Then we can get the result.**O(m + n)** 

The solution of the author has to be proved by math:

First, we can divide nums1 into two parts, left1 and right1. Also, divide nums2 into two parts, left2 and right2. To  find the median, we should make sure **left1 + left2 = right1 + right2 (if total number is even.otherwise right1 + right2 + 1)**. 

Because nums1 and nums2 are sorted arrays, so max(left1) should lower than min(right1) and max(left2) should lower than min(right2). 

And for the median, we should also make sure max(left1) lower than min(right2), max(left2) lower than min(right1). if the nums1's elements 0......i-1 in left1, i......m-1 in right1, nums2's elements 0......j-1 in left2, j......n-1 in right2. We can assume that:

```
1. i + j = m - i + n - j + 1 (total number is odd) -> j = (m + n + 1) / 2 - i

2. nums1[i - 1] < nums2[j]

3. nums2[j - 1] < nums1[i]
```

What if **i = 0, j = 0, i = m, j = n**? Then nums1[i - 1], nums2[j - 1], nums1[i], nums[j] may not exist. In this case, we need not compare the numbers in the condition2 or condition3.

And what if one of the array is empty? Then the problem turns into single array median. Just using binary sarch for one array is ok.

So, according to the analysis, we can get the process of this problem's solution:

```
1.Make sure n >= m, because of the equation j = (m + n + 1) / 2 - i

2.Make sure (i == 0 || j == n || nums1[i - 1] < nums2[j]) && (j == 0 || i == m || nums2[j - 1] < nums1[i]) 

3.If the situation does not match situation2, using binary search to find a perfect i (from 0 to m)

4.If one of the array is empty, using binary search to find median in another array. 

5.If total number is odd, then the median is max(left1, left2).

6.If total number is even, then the median is (max(left1, left2) + min(right1, right2)) / 2.0 (2.0 is important because of float number)
```

so the **O(log(m + n))** is:

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int i;
        int j;
        int m = nums1.size();
        int n = nums2.size();
        if (m == 0) {
            if (n % 2 == 0) {
                return (nums2[n / 2] + nums2[n / 2 - 1]) / 2.0;
            }
            else {
                return nums2[n / 2];
            }
        }
        else if (n == 0) {
            if (m % 2 == 0) {
                return (nums1[m / 2] + nums1[m / 2 - 1]) / 2.0;
            }
            else {
                return nums1[m / 2];
            }
        }
        if (m > n) {
            swap(nums1, nums2);
            int tmp = m;
            m = n;
            n = tmp;
        }
        int imax = m;
        int imin = 0;
        while(imax >= imin) {
            i = (imax + imin) / 2;
            j = (m + n + 1) / 2 - i;
            if(i < imax && nums1[i] < nums2[j - 1]) {
                imin = i + 1; // i is too small
            }
            else if(i > imin && nums1[i - 1] > nums2[j]) {
                imax = i - 1; // i is too big
            }
            else {
                int bigger = 0;
                int smaller = 0;
                if(i == 0) {
                    smaller = nums2[j - 1];
                }
                else if (j == 0) {
                    smaller = nums1[i - 1];
                }
                else {
                    smaller = max(nums1[i - 1], nums2[j - 1]);
                }
                if (i == m) {
                    bigger = nums2[j];
                }
                else if (j == n) {
                    bigger = nums1[i];
                }
                else {
                    bigger = min(nums1[i], nums2[j]);
                }
                if ((m + n) % 2 == 0) {
                    return (bigger + smaller) / 2.0;
                }
                else {
                    return smaller;
                }
            }
        }
        return 0.0;
    }
};
```



 