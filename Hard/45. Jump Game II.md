**Problem:**

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

**Example:**

```
Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Note:**

You can assume that you can always reach the last index.

**Solution:**

We can greedy algorithm. When we are at i point, we have to find a j in [i, i + nums[i]], which can reach the furtherest point.

So the solution is:

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() <= 1) {
            return 0;
        }
        int i = 0;
        int step = 0;
        while(1) {
            if (nums[i] + i >= nums.size() - 1) {
                return ++step;
            }
            int max = 0;
            int remember = i;
            for (int j = i; j <= i + nums[i]; j++) {
                if (max < j + nums[j]) {
                    max = j + nums[j];
                    remember = j;
                }
            }
            i = remember;
            step++;
        }
        return step;
    }
};
```

And also we can use way just like the "rabbit jumps the stairs", the recursion way.

We can know, if we want to reach i, the min steps we should take is the steps of reaching [1, i - 1] adds 1. Because we have to reach i after reach [1, i - 1] assuming that we can not reach i directly. 

So if we look from the end of the array, we have to find the min steps of reaching[1, end - 1].

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        vector<int> min_jumps(nums.size());
        int current = 0, reach = 1;
        while(reach < nums.size()){
            for(; (reach <= current + nums[current]) && reach < nums.size(); reach++ ){
                min_jumps[reach] = min_jumps[current] + 1;
            }
            current++;
        }
        return min_jumps.back();
    }
};
```

And we can just scan the array once, if we take the solution one, we may scan some elements more than once.

Using two pointers to do this. 

First, putting max_reach and i at the start of the array. Then update the max_reach according to the nums[i] + i which is the furtherest point we can reach now.

And update i, meanwhile update the curr_reach we can reach from i now.

When i == max_reach, we can update it based on curr_reach. Because in the solution one we have to scan all the range we can reach from [i, nums[i] + i]. In this case, we can just scan the array once, and remember the max value we meet, then update.

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int curr_reach=0, max_reach=0, steps=0;
        for(int i = 0; i < nums.size()-1; i++){
            curr_reach = max(curr_reach, nums[i] + i); //current reach from the node
            if(i == max_reach){ // one phase of bfs is over
                steps++; // increase the steps, same as the distance update in the BFS
                max_reach = max(max_reach, curr_reach); //update the BFS limit for next phase        
            }
        }
        return steps;
    }
};
```

