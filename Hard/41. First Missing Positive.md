**Problem**:

Given an unsorted integer array, find the smallest missing positive integer.

**Example 1:**

```
Input: [1,2,0]
Output: 3
```

**Example 2:**

```
Input: [3,4,-1,1]
Output: 2
```

**Example 3:**

```
Input: [7,8,9,11,12]
Output: 1
```

**Note:**

Your algorithm should run in *O*(*n*) time and uses constant extra space.

**Solution**:

First solution is that sorting the array, then use patience to detect the condition of different case. (which may run fast but difficult to finish).

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        if (nums.size() == 0) {
            return 1;
        }
        else if (nums.size() == 1) {
            if (nums[0] <= 0 || nums[0] > 1) {
                return 1;
            }
            else {
                return 2;
            }
        }
        if (nums[nums.size() - 1] <= 0) {
            return 1;
        }
        int k;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] >= 0) {
                k = i;
                break;
            }
        }
        if (nums[k] > 1) {
            return 1;
        }
        else {
            for (int i = k; i < nums.size() - 1; i++) {
                if (nums[i] < nums[i + 1] - 1) {
                    return nums[i] + 1;
                }
            }
            return nums[nums.size() - 1] + 1;
        }
    }
};
```

Second one is a faster way. To match the index and the value in the array, we should insert 0 into the array. 

Because we can know from the problem that the number which is lost **must be in [1......nums.size()]**, so we can change the number out of the range into 0.

```
1.After the prerequiste, we add n to nums[nums[i] % n]. nums[i] % n must be in [1......nums.size()], so we map the value to the index. (mode n is because we maybe add n to the value between 1 and nums.size() in the array)

2.Then we can know, the first 0 value (after divide n) matches the lost index(value). Return it
```

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
    	nums.insert (nums.begin(), 0);
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            if(nums[i] < 0 || nums[i] >= n){
                nums[i]=0;
            }
        }
        for(int i = 0; i < n; i++) {
            nums[nums[i] % n] += n;
        }
        for(int i = 0; i < n; i++) {
            if (nums[i] / n == 0) {
                return i;
            }
        }
        return n;
    }
};
```

Third way is a little like second way, they use index to reflect the value. But third way is to **swap the value to the correct index.** (value i matches index i - 1)

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.size() < 1){
            return 1;
        } 
        int index = 0; 
        while (index < nums.size()) {
            if (nums[index] >= 1 && nums[index] <= nums.size() && nums[index] != index + 1 && nums[nums[index] - 1] != nums[index]) {
                int temp = nums[nums[index] - 1];
                nums[nums[index] - 1] = nums[index];
                nums[index] = temp;
            }
            else {
                index++;
            }
        }
  
        int rst = 1;
    
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] != i + 1) {
                break;
            } 
            else {
                rst++;
            }
        }
    
        return rst;
    }
};
```

Fourth way is the same as third way, but it has not to swap two value, it use opposite value of the original value to mark which one is lost. (because it change the value out of [1......nums.size()] to nums.size() + 1, so he can skip them, then the first positive value in the array matches the min lost value).

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
    
        // 1. mark numbers (num < 0) and (num > n) with a special marker number (n+1) 
        // (we can ignore those because if all number are > n then we'll simply return 1)
        for (int i = 0; i < n; i++) {
            if (nums[i] <= 0 || nums[i] > n) {
                nums[i] = n + 1;
            }
        }
        // note: all number in the array are now positive, and on the range 1..n+1
    
        // 2. mark each cell appearing in the array, by converting the index for that number to negative
        for (int i = 0; i < n; i++) {
            int num = abs(nums[i]);
            if (num > n) {
                continue;
            }
            num--; // -1 for zero index based array (so the number 1 will be at pos 0)
            if (nums[num] > 0) { // prevents double negative operations
                nums[num] = -1 * nums[num];
            }
        }
    
        // 3. find the first cell which isn't negative (doesn't appear in the array)
        for (int i = 0; i < n; i++) {
            if (nums[i] >= 0) {
                return i + 1;
            }
        }
    
        // 4. no positive numbers were found, which means the array contains all numbers 1..n
        return n + 1;
    }
};
```

But we can change it into a better solution.

In this case, we change the original value, it means we lost some information in it, so if we use shifting, we can back to the original array (but if the value bigger than **1073741824**, we can not return).

And because we can not shift negative value in c++, so we put java code here.

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
	// We're going to use the rightmost bit in each number to indicate whether that index position for that number was found in the array. 
	
	// Make space for our flag, in the rightmost bit (so we don't destroy the numbers)
        for(int i = 0; i < nums.length; i++) {
            nums[i] = nums[i] << 1;
        }
        
        for(int i = 0; i < nums.length; i++) {
		// Skip any numbers larger than array length, or less than zero (converting back to the original unbitshifted numbers for comparison)
            if ((nums[i] >> 1) > nums.length || (nums[i] >> 1) <= 0) {
                continue;
            }
            // If we haven't already set our flag, set it for the array index of the original unbitshifted number minus one.
            if ((nums[(nums[i] >> 1) - 1] & 1) != 1) {
                nums[(nums[i] >> 1) - 1] = nums[(nums[i] >> 1) - 1] | 1;
            }
        }
        
        int result = nums.length + 1;
        
		// Find the first position in the index where our flag has not been set, and store it in result.
        for(int i = 0; i < nums.length; i++) {
            if ((nums[i] & 1) != 1) {
                result = i + 1;
                break;
            }
        }
		
        // Bitshift all the numbers back, to remove our flag.
        for(int i = 0; i < nums.length; i++) {
            nums[i] = nums[i] >> 1;
            // Optional printout if you want to see the state of the input array.
            //System.out.print(nums[i] + " ");
        }
        //System.out.println();
        
        return result;
    }
}
```

