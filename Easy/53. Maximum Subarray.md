**Problem:**

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

**Example:**

```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Follow up:**

If you have figured out the O(*n*) solution, try coding another solution using the divide and conquer approach, which is more subtle.

**Solution:**

A brute force way. Pay attention to the initial value of "max".

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int max = -2147483647;
        int sum;
        for (int i = 0; i < nums.size(); i++) {
            sum = nums[i];
            if (sum > max) {
                max = sum;
            }
            for (int j = i + 1; j < nums.size(); j++) {
                sum += nums[j];
                if (sum > max) {
                    max = sum;
                }
            }
        }
        return max;
    }
};
```

The second solution is that if we divide the array into two parts, the maxsubarray is in the left part, or in the right part, or each part contains some of it.

So we can use  recursion to find these three maxsubarray, and compare them, to find the maxsubarray.

```c++
class Solution {
public:
    
    int maxSubSumRec(vector<int>& nums, int left, int right){
        
        if(left >= right){
            return nums[left];
        }
        
        int i,center;
        center = (left + right)/2;
        int lmax = maxSubSumRec(nums, left, center - 1);
        int rmax = maxSubSumRec(nums, center +1, right);
        int mmax = nums[center], t = mmax;
        
        for(i = center - 1; i >= left; --i){
            t += nums[i];
            mmax = max(mmax, t);
        }
        
        t = mmax;
        for(i = center + 1; i <=right; ++i){
            t += nums[i];
            mmax = max(mmax, t);
        }
        
        return max(mmax, max(lmax, rmax));
    }
    
    
    int maxSubArray(vector<int>& nums) {
        
        int length = int(nums.size()-1);
        return maxSubSumRec(nums, 0, length);
    }
};
```

The final way is Kadane's algorithm.

To each index in this array, we can find the maxsubarray ending at this point.

If we scan this array, we can remember the **maxsubarray of [i......j]**, so next maxsubarray is either [i......j + 1] or [j + 1]. Because if there is a [t......j] either contains the [i......j] or contained by the [i......j], we've already know the maxsubarray before [j + 1] is [i......j], thus we can konw that [t......j + 1] must be equal to or smaller than [i......j + 1].

And maybe [j + 1] is bigger than [i......j + 1], so we pick the max of these two numbers.

We also remember the global_max, and if global_max < maxsubarray, we have to update the value.

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        int maxcurrent = nums[0];
        int maxglobal = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            maxcurrent = max(nums[i], maxcurrent + nums[i]);
            maxglobal = max(maxcurrent, maxglobal);
        }
        return maxglobal;
    }
};
```

